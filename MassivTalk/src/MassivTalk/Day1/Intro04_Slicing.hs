{-# OPTIONS_GHC -Wno-missing-signatures #-}
{-# LANGUAGE FlexibleContexts #-}
module MassivTalk.Day1.Intro04_Slicing where

import Prelude as P
import Data.Massiv.Array as A


---------------------
-- Class Hierarchy --
---------------------

-- class Index ix => Resize r ix where

-- class Load r ix e => Extract r ix e where


-- class Load r ix e => OuterSlice r ix e where

-- class Load r ix e => InnerSlice r ix e where

-- class Load r ix e => Slice r ix e where



sampleArr = computeAs U $ fromIx3 <$> (0 :> 0 :. 0 ... 4 :> 2 :. 6)

sampleArr' = computeAs U (fmap fromIx3 (rangeInclusive Seq (0 :> 0 :. 0) (4 :> 2 :. 6)))


--
-- >>> sampleArr == sampleArr'
-- True
-- >>> sampleArr
-- Array U Seq (Sz (5 :> 3 :. 7))
--   [ [ [ (0,0,0), (0,0,1), (0,0,2), (0,0,3), (0,0,4), (0,0,5), (0,0,6) ]
--     , [ (0,1,0), (0,1,1), (0,1,2), (0,1,3), (0,1,4), (0,1,5), (0,1,6) ]
--     , [ (0,2,0), (0,2,1), (0,2,2), (0,2,3), (0,2,4), (0,2,5), (0,2,6) ]
--     ]
--   , [ [ (1,0,0), (1,0,1), (1,0,2), (1,0,3), (1,0,4), (1,0,5), (1,0,6) ]
--     , [ (1,1,0), (1,1,1), (1,1,2), (1,1,3), (1,1,4), (1,1,5), (1,1,6) ]
--     , [ (1,2,0), (1,2,1), (1,2,2), (1,2,3), (1,2,4), (1,2,5), (1,2,6) ]
--     ]
--   , [ [ (2,0,0), (2,0,1), (2,0,2), (2,0,3), (2,0,4), (2,0,5), (2,0,6) ]
--     , [ (2,1,0), (2,1,1), (2,1,2), (2,1,3), (2,1,4), (2,1,5), (2,1,6) ]
--     , [ (2,2,0), (2,2,1), (2,2,2), (2,2,3), (2,2,4), (2,2,5), (2,2,6) ]
--     ]
--   , [ [ (3,0,0), (3,0,1), (3,0,2), (3,0,3), (3,0,4), (3,0,5), (3,0,6) ]
--     , [ (3,1,0), (3,1,1), (3,1,2), (3,1,3), (3,1,4), (3,1,5), (3,1,6) ]
--     , [ (3,2,0), (3,2,1), (3,2,2), (3,2,3), (3,2,4), (3,2,5), (3,2,6) ]
--     ]
--   , [ [ (4,0,0), (4,0,1), (4,0,2), (4,0,3), (4,0,4), (4,0,5), (4,0,6) ]
--     , [ (4,1,0), (4,1,1), (4,1,2), (4,1,3), (4,1,4), (4,1,5), (4,1,6) ]
--     , [ (4,2,0), (4,2,1), (4,2,2), (4,2,3), (4,2,4), (4,2,5), (4,2,6) ]
--     ]
--   ]

-- | Slice from both sides and from within

--
-- >>> sampleArr !> 1
-- Array M Seq (Sz (3 :. 7))
--   [ [ (1,0,0), (1,0,1), (1,0,2), (1,0,3), (1,0,4), (1,0,5), (1,0,6) ]
--   , [ (1,1,0), (1,1,1), (1,1,2), (1,1,3), (1,1,4), (1,1,5), (1,1,6) ]
--   , [ (1,2,0), (1,2,1), (1,2,2), (1,2,3), (1,2,4), (1,2,5), (1,2,6) ]
--   ]

--
-- >>> sampleArr <! 0
-- Array M Seq (Sz (5 :. 3))
--   [ [ (0,0,0), (0,1,0), (0,2,0) ]
--   , [ (1,0,0), (1,1,0), (1,2,0) ]
--   , [ (2,0,0), (2,1,0), (2,2,0) ]
--   , [ (3,0,0), (3,1,0), (3,2,0) ]
--   , [ (4,0,0), (4,1,0), (4,2,0) ]
--   ]

--
-- >>> sampleArr <!> (2, 1)
-- Array M Seq (Sz (5 :. 7))
--   [ [ (0,1,0), (0,1,1), (0,1,2), (0,1,3), (0,1,4), (0,1,5), (0,1,6) ]
--   , [ (1,1,0), (1,1,1), (1,1,2), (1,1,3), (1,1,4), (1,1,5), (1,1,6) ]
--   , [ (2,1,0), (2,1,1), (2,1,2), (2,1,3), (2,1,4), (2,1,5), (2,1,6) ]
--   , [ (3,1,0), (3,1,1), (3,1,2), (3,1,3), (3,1,4), (3,1,5), (3,1,6) ]
--   , [ (4,1,0), (4,1,1), (4,1,2), (4,1,3), (4,1,4), (4,1,5), (4,1,6) ]
--   ]

-- | Slice chaining

--
-- >>> sampleArr !> 1 !> 2
-- Array M Seq (Sz1 7)
--   [ (1,2,0), (1,2,1), (1,2,2), (1,2,3), (1,2,4), (1,2,5), (1,2,6) ]

--
-- >>> sampleArr !> 1 !> 2 !> 0
-- (1,2,0)

-- | Safe slicing

--
-- >>> :t (!>)
-- (!>) :: OuterSlice r ix e => Array r ix e -> Int -> Elt r ix e

--
-- >>> sampleArr !> 10
-- Array M *** Exception: IndexOutOfBoundsException: 10 not safe for (Sz1 5)

-- >>> :t (!?>)
-- (!?>)
--   :: (MonadThrow m, OuterSlice r ix e) =>
--      Array r ix e -> Int -> m (Elt r ix e)
-- >>> :t (??>)
-- (??>)
--   :: (MonadThrow m, OuterSlice r ix e) =>
--      m (Array r ix e) -> Int -> m (Elt r ix e)

--
-- >>> sampleArr !?> 10
-- *** Exception: IndexOutOfBoundsException: 10 not safe for (Sz1 5)

--
-- >>> import Data.Maybe
-- >>> fromMaybe A.empty $ sampleArr !?> 10
-- Array M Seq (Sz (0 :. 0))
--   [  ]

-- >>> :t (??>)
-- (??>)
--   :: (MonadThrow m, OuterSlice r ix e) =>
--      m (Array r ix e) -> Int -> m (Elt r ix e)

--
-- >>> x <- sampleArr !?> 1 ??> 2 ??> 10
-- >>> print x

--
-- >>> let x = sampleArr !> 1 !> 2 !> 10
-- >>> print x


{-
ocut ::
     (MonadThrow m, OuterSlice r ix e) => Int -> Array r ix e -> m (Elt r ix e)
ocut = flip (!?>)
λ> sampleArr !?> 1 >>= ocut 2 >>= ocut 0
(1,2,0)
λ> sampleArr !?> 1 ??> 2 ??> 0
-}

dot ::
     (Num e, Source r1 ix e, Source r2 ix e)
  => Array r1 ix e
  -> Array r2 ix e
  -> e
dot v1 v2 = A.sum $ A.zipWith (*) v1 v2


-- | Matrix multiplication

multArrays ::
     Array U Ix2 Double
  -> Array U Ix2 Double
  -> Array D Ix2 Double
multArrays arr1 arr2
  | n1 == m2 =
    makeArray (getComp arr1 <> getComp arr2) (Sz2 m1 n2) $ \(i :. j) ->
      dot (arr1 !> i) (arr2 <! j)
  | otherwise = error "multArrays: Inner size mismatch"
  where
    Sz2 m1 n1 = size arr1
    Sz2 m2 n2 = size arr2



--
-- >>> a1 = makeArrayR P Seq (Sz2 2 3) $ \ (i :. j) -> i + j
-- >>> a2 = makeArrayR P Seq (Sz2 3 2) $ \ (i :. j) -> i * j + 1
-- >>> multArrays a1 a2 :: Array P Ix2 Int
-- Array P Seq (Sz (2 :. 2))
--   [ [ 3, 8 ]
--   , [ 6, 14 ]
--   ]
-- >>> a1 |*| a2 :: Array P Ix2 Int
-- Array P Seq (Sz (2 :. 2))
--   [ [ 3, 8 ]
--   , [ 6, 14 ]
--   ]



-- | Extracting

--
-- >>> sampleArr
-- Array U Seq (Sz (5 :> 3 :. 7))
--   [ [ [ (0,0,0), (0,0,1), (0,0,2), (0,0,3), (0,0,4), (0,0,5), (0,0,6) ]
--     , [ (0,1,0), (0,1,1), (0,1,2), (0,1,3), (0,1,4), (0,1,5), (0,1,6) ]
--     , [ (0,2,0), (0,2,1), (0,2,2), (0,2,3), (0,2,4), (0,2,5), (0,2,6) ]
--     ]
--   , [ [ (1,0,0), (1,0,1), (1,0,2), (1,0,3), (1,0,4), (1,0,5), (1,0,6) ]
--     , [ (1,1,0), (1,1,1), (1,1,2), (1,1,3), (1,1,4), (1,1,5), (1,1,6) ]
--     , [ (1,2,0), (1,2,1), (1,2,2), (1,2,3), (1,2,4), (1,2,5), (1,2,6) ]
--     ]
--   , [ [ (2,0,0), (2,0,1), (2,0,2), (2,0,3), (2,0,4), (2,0,5), (2,0,6) ]
--     , [ (2,1,0), (2,1,1), (2,1,2), (2,1,3), (2,1,4), (2,1,5), (2,1,6) ]
--     , [ (2,2,0), (2,2,1), (2,2,2), (2,2,3), (2,2,4), (2,2,5), (2,2,6) ]
--     ]
--   , [ [ (3,0,0), (3,0,1), (3,0,2), (3,0,3), (3,0,4), (3,0,5), (3,0,6) ]
--     , [ (3,1,0), (3,1,1), (3,1,2), (3,1,3), (3,1,4), (3,1,5), (3,1,6) ]
--     , [ (3,2,0), (3,2,1), (3,2,2), (3,2,3), (3,2,4), (3,2,5), (3,2,6) ]
--     ]
--   , [ [ (4,0,0), (4,0,1), (4,0,2), (4,0,3), (4,0,4), (4,0,5), (4,0,6) ]
--     , [ (4,1,0), (4,1,1), (4,1,2), (4,1,3), (4,1,4), (4,1,5), (4,1,6) ]
--     , [ (4,2,0), (4,2,1), (4,2,2), (4,2,3), (4,2,4), (4,2,5), (4,2,6) ]
--     ]
--   ]

--
-- >>> :t extractM
-- extractM
--   :: (MonadThrow m, Extract r ix e) =>
--      ix -> Sz ix -> Array r ix e -> m (Array (EltRepr r ix) ix e)

--
-- >>> extractM (1 :> 0 :. 1) (Sz3 3 2 5) sampleArr
-- Array M Seq (Sz (3 :> 2 :. 5))
--   [ [ [ (1,0,1), (1,0,2), (1,0,3), (1,0,4), (1,0,5) ]
--     , [ (1,1,1), (1,1,2), (1,1,3), (1,1,4), (1,1,5) ]
--     ]
--   , [ [ (2,0,1), (2,0,2), (2,0,3), (2,0,4), (2,0,5) ]
--     , [ (2,1,1), (2,1,2), (2,1,3), (2,1,4), (2,1,5) ]
--     ]
--   , [ [ (3,0,1), (3,0,2), (3,0,3), (3,0,4), (3,0,5) ]
--     , [ (3,1,1), (3,1,2), (3,1,3), (3,1,4), (3,1,5) ]
--     ]
--   ]


-- | Extract and lower the dimensionality

--
-- >>> extractM (1 :> 0 :. 1) (Sz3 3 1 5) sampleArr
-- Array M Seq (Sz (3 :> 1 :. 5))
--   [ [ [ (1,0,1), (1,0,2), (1,0,3), (1,0,4), (1,0,5) ]
--     ]
--   , [ [ (2,0,1), (2,0,2), (2,0,3), (2,0,4), (2,0,5) ]
--     ]
--   , [ [ (3,0,1), (3,0,2), (3,0,3), (3,0,4), (3,0,5) ]
--     ]
--   ]

--
-- >>> subArr <- extractM (1 :> 0 :. 1) (Sz3 3 1 5) sampleArr
-- >>> resizeM (Sz2 2 5) subArr

